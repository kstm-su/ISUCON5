/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of SQLite.xs. Do not edit this file, edit SQLite.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SQLite.xs"
#define PERL_NO_GET_CONTEXT

#include "SQLiteXS.h"

DBISTATE_DECLARE;

#line 17 "SQLite.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 159 "SQLite.c"

XS_EUPXS(XS_DBD__SQLite__db_last_insert_rowid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_last_insert_rowid)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	IV	RETVAL;
	dXSTARG;
#line 21 "SQLite.xs"
    {
        D_imp_dbh(dbh);
        RETVAL = (IV)sqlite3_last_insert_rowid(imp_dbh->db);
    }
#line 178 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_create_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_create_function)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, name, argc, func");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	int	argc = (int)SvIV(ST(2))
;
	SV *	func = ST(3)
;
	int	RETVAL;
	dXSTARG;
#line 37 "SQLite.xs"
    {
        RETVAL = sqlite_db_create_function(aTHX_ dbh, name, argc, func );
    }
#line 207 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifndef SQLITE_OMIT_LOAD_EXTENSION
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_DBD__SQLite__db_enable_load_extension); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_enable_load_extension)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, onoff");
    {
	SV *	dbh = ST(0)
;
	int	onoff = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 52 "SQLite.xs"
    {
        RETVAL = sqlite_db_enable_load_extension(aTHX_ dbh, onoff );
    }
#line 235 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_load_extension); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_load_extension)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, file, proc = 0");
    {
	SV *	dbh = ST(0)
;
	const char *	file = (const char *)SvPV_nolen(ST(1))
;
	const char *	proc;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    proc = 0;
	else {
	    proc = (const char *)SvPV_nolen(ST(2))
;
	}
#line 66 "SQLite.xs"
    {
        RETVAL = sqlite_db_load_extension(aTHX_ dbh, file, proc);
    }
#line 268 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__SQLite__db_create_aggregate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_create_aggregate)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, name, argc, aggr");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	int	argc = (int)SvIV(ST(2))
;
	SV *	aggr = ST(3)
;
	int	RETVAL;
	dXSTARG;
#line 83 "SQLite.xs"
    {
        RETVAL = sqlite_db_create_aggregate(aTHX_ dbh, name, argc, aggr );
    }
#line 298 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_create_collation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_create_collation)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, name, func");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	SV *	func = ST(2)
;
	int	RETVAL;
	dXSTARG;
#line 97 "SQLite.xs"
    {
        RETVAL = sqlite_db_create_collation(aTHX_ dbh, name, func );
    }
#line 325 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_collation_needed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_collation_needed)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, callback");
    {
	SV *	dbh = ST(0)
;
	SV *	callback = ST(1)
;
#line 111 "SQLite.xs"
    {
        sqlite_db_collation_needed(aTHX_ dbh, callback );
    }
#line 348 "SQLite.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_DBD__SQLite__db_progress_handler); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_progress_handler)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, n_opcodes, handler");
    {
	SV *	dbh = ST(0)
;
	int	n_opcodes = (int)SvIV(ST(1))
;
	SV *	handler = ST(2)
;
	int	RETVAL;
	dXSTARG;
#line 124 "SQLite.xs"
    {
        RETVAL = sqlite_db_progress_handler(aTHX_ dbh, n_opcodes, handler );
    }
#line 374 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_sqlite_trace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_sqlite_trace)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, callback");
    {
	SV *	dbh = ST(0)
;
	SV *	callback = ST(1)
;
	int	RETVAL;
	dXSTARG;
#line 135 "SQLite.xs"
    {
        RETVAL = sqlite_db_trace(aTHX_ dbh, callback );
    }
#line 398 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_profile)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, callback");
    {
	SV *	dbh = ST(0)
;
	SV *	callback = ST(1)
;
	int	RETVAL;
	dXSTARG;
#line 148 "SQLite.xs"
    {
        RETVAL = sqlite_db_profile(aTHX_ dbh, callback );
    }
#line 423 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_commit_hook); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_commit_hook)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, hook");
    {
	SV *	dbh = ST(0)
;
	SV *	hook = ST(1)
;
	SV *	RETVAL;
#line 161 "SQLite.xs"
    {
        RETVAL = (SV*) sqlite_db_commit_hook( aTHX_ dbh, hook );
    }
#line 447 "SQLite.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_rollback_hook); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_rollback_hook)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, hook");
    {
	SV *	dbh = ST(0)
;
	SV *	hook = ST(1)
;
	SV *	RETVAL;
#line 174 "SQLite.xs"
    {
        RETVAL = (SV*) sqlite_db_rollback_hook( aTHX_ dbh, hook );
    }
#line 472 "SQLite.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_update_hook); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_update_hook)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, hook");
    {
	SV *	dbh = ST(0)
;
	SV *	hook = ST(1)
;
	SV *	RETVAL;
#line 187 "SQLite.xs"
    {
        RETVAL = (SV*) sqlite_db_update_hook( aTHX_ dbh, hook );
    }
#line 497 "SQLite.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_set_authorizer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_set_authorizer)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, authorizer");
    {
	SV *	dbh = ST(0)
;
	SV *	authorizer = ST(1)
;
	int	RETVAL;
	dXSTARG;
#line 201 "SQLite.xs"
    {
        RETVAL = sqlite_db_set_authorizer( aTHX_ dbh, authorizer );
    }
#line 523 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_busy_timeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_busy_timeout)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, timeout=0");
    {
	SV *	dbh = ST(0)
;
	int	timeout;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    timeout = 0;
	else {
	    timeout = (int)SvIV(ST(1))
;
	}
#line 215 "SQLite.xs"
        RETVAL = sqlite_db_busy_timeout(aTHX_ dbh, timeout );
#line 552 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_backup_from_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_backup_from_file)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, filename");
    {
	SV *	dbh = ST(0)
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 226 "SQLite.xs"
        RETVAL = sqlite_db_backup_from_file(aTHX_ dbh, filename);
#line 575 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_backup_to_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_backup_to_file)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, filename");
    {
	SV *	dbh = ST(0)
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 237 "SQLite.xs"
        RETVAL = sqlite_db_backup_to_file(aTHX_ dbh, filename);
#line 598 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_table_column_metadata); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_table_column_metadata)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, dbname, tablename, columnname");
    {
	SV*	dbh = ST(0)
;
	SV*	dbname = ST(1)
;
	SV*	tablename = ST(2)
;
	SV*	columnname = ST(3)
;
	HV *	RETVAL;
#line 250 "SQLite.xs"
        RETVAL = sqlite_db_table_column_metadata(aTHX_ dbh, dbname, tablename, columnname);
#line 624 "SQLite.c"
        ST(0) = newRV_noinc((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_db_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_db_filename)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV*	dbh = ST(0)
;
	SV *	RETVAL;
#line 260 "SQLite.xs"
        RETVAL = sqlite_db_filename(aTHX_ dbh);
#line 645 "SQLite.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_register_fts3_perl_tokenizer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_register_fts3_perl_tokenizer)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 270 "SQLite.xs"
        RETVAL = sqlite_db_register_fts3_perl_tokenizer(aTHX_ dbh);
#line 667 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_db_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_db_status)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, reset = 0");
    {
	SV*	dbh = ST(0)
;
	int	reset;
	HV *	RETVAL;

	if (items < 2)
	    reset = 0;
	else {
	    reset = (int)SvIV(ST(1))
;
	}
#line 281 "SQLite.xs"
        RETVAL = (HV*)_sqlite_db_status(aTHX_ dbh, reset);
#line 695 "SQLite.c"
        ST(0) = newRV_noinc((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_st_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_st_status)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "sth, reset = 0");
    {
	SV*	sth = ST(0)
;
	int	reset;
	HV *	RETVAL;

	if (items < 2)
	    reset = 0;
	else {
	    reset = (int)SvIV(ST(1))
;
	}
#line 297 "SQLite.xs"
        RETVAL = (HV*)_sqlite_st_status(aTHX_ sth, reset);
#line 724 "SQLite.c"
        ST(0) = newRV_noinc((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_compile_options); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_compile_options)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 310 "SQLite.xs"
        int n = 0;
        AV* av = (AV*)sqlite_compile_options();
        if (av) {
            int i;
            n = av_len(av) + 1;
            EXTEND(sp, n);
            for (i = 0; i < n; i++) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
        XSRETURN(n);
#line 753 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_sqlite_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_sqlite_status)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "reset = 0");
    {
	int	reset;
	HV *	RETVAL;

	if (items < 1)
	    reset = 0;
	else {
	    reset = (int)SvIV(ST(0))
;
	}
#line 326 "SQLite.xs"
        RETVAL = (HV*)_sqlite_status(reset);
#line 777 "SQLite.c"
        ST(0) = newRV_noinc((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_OK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_OK)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 333 "SQLite.xs"
        RETVAL = SQLITE_OK;
#line 796 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DENY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DENY)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 340 "SQLite.xs"
        RETVAL = SQLITE_DENY;
#line 814 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_IGNORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_IGNORE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 347 "SQLite.xs"
        RETVAL = SQLITE_IGNORE;
#line 832 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_INDEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_INDEX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 354 "SQLite.xs"
        RETVAL = SQLITE_CREATE_INDEX;
#line 850 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_TABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_TABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 361 "SQLite.xs"
        RETVAL = SQLITE_CREATE_TABLE;
#line 868 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_INDEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_INDEX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 368 "SQLite.xs"
        RETVAL = SQLITE_CREATE_TEMP_INDEX;
#line 886 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_TABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_TABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 375 "SQLite.xs"
        RETVAL = SQLITE_CREATE_TEMP_TABLE;
#line 904 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_TRIGGER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_TRIGGER)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 382 "SQLite.xs"
        RETVAL = SQLITE_CREATE_TEMP_TRIGGER;
#line 922 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_VIEW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_TEMP_VIEW)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 389 "SQLite.xs"
        RETVAL = SQLITE_CREATE_TEMP_VIEW;
#line 940 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_TRIGGER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_TRIGGER)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 396 "SQLite.xs"
        RETVAL = SQLITE_CREATE_TRIGGER;
#line 958 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_VIEW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_VIEW)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 403 "SQLite.xs"
        RETVAL = SQLITE_CREATE_VIEW;
#line 976 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DELETE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DELETE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 410 "SQLite.xs"
        RETVAL = SQLITE_DELETE;
#line 994 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_INDEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_INDEX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 417 "SQLite.xs"
        RETVAL = SQLITE_DROP_INDEX;
#line 1012 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_TABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_TABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 424 "SQLite.xs"
        RETVAL = SQLITE_DROP_TABLE;
#line 1030 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_INDEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_INDEX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 431 "SQLite.xs"
        RETVAL = SQLITE_DROP_TEMP_INDEX;
#line 1048 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_TABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_TABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 438 "SQLite.xs"
        RETVAL = SQLITE_DROP_TEMP_TABLE;
#line 1066 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_TRIGGER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_TRIGGER)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 445 "SQLite.xs"
        RETVAL = SQLITE_DROP_TEMP_TRIGGER;
#line 1084 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_VIEW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_TEMP_VIEW)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 452 "SQLite.xs"
        RETVAL = SQLITE_DROP_TEMP_VIEW;
#line 1102 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_TRIGGER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_TRIGGER)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 459 "SQLite.xs"
        RETVAL = SQLITE_DROP_TRIGGER;
#line 1120 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_VIEW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_VIEW)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 466 "SQLite.xs"
        RETVAL = SQLITE_DROP_VIEW;
#line 1138 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_INSERT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_INSERT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 473 "SQLite.xs"
        RETVAL = SQLITE_INSERT;
#line 1156 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_PRAGMA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_PRAGMA)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 480 "SQLite.xs"
        RETVAL = SQLITE_PRAGMA;
#line 1174 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_READ); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_READ)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 487 "SQLite.xs"
        RETVAL = SQLITE_READ;
#line 1192 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_SELECT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_SELECT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 494 "SQLite.xs"
        RETVAL = SQLITE_SELECT;
#line 1210 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_TRANSACTION); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_TRANSACTION)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 501 "SQLite.xs"
        RETVAL = SQLITE_TRANSACTION;
#line 1228 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_UPDATE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_UPDATE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 508 "SQLite.xs"
        RETVAL = SQLITE_UPDATE;
#line 1246 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_ATTACH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_ATTACH)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 515 "SQLite.xs"
        RETVAL = SQLITE_ATTACH;
#line 1264 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DETACH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DETACH)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 522 "SQLite.xs"
        RETVAL = SQLITE_DETACH;
#line 1282 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_ALTER_TABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_ALTER_TABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 529 "SQLite.xs"
        RETVAL = SQLITE_ALTER_TABLE;
#line 1300 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_REINDEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_REINDEX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 536 "SQLite.xs"
        RETVAL = SQLITE_REINDEX;
#line 1318 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_ANALYZE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_ANALYZE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 543 "SQLite.xs"
        RETVAL = SQLITE_ANALYZE;
#line 1336 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_CREATE_VTABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_CREATE_VTABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 550 "SQLite.xs"
        RETVAL = SQLITE_CREATE_VTABLE;
#line 1354 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_DROP_VTABLE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_DROP_VTABLE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 557 "SQLite.xs"
        RETVAL = SQLITE_DROP_VTABLE;
#line 1372 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_FUNCTION); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_FUNCTION)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 564 "SQLite.xs"
        RETVAL = SQLITE_FUNCTION;
#line 1390 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite_SAVEPOINT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite_SAVEPOINT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 571 "SQLite.xs"
#if SQLITE_VERSION_NUMBER >= 3006011
        RETVAL = SQLITE_SAVEPOINT;
#else
		RETVAL = -1;
#endif
#line 1412 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE:  Including 'SQLite.xsi' from 'SQLite.xs' */

#include "Driver_xst.h"

XS_EUPXS(XS_DBD__SQLite__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__dr_dbixs_revision)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 36 "./SQLite.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 1433 "SQLite.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_DBD__SQLite__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__dr_discon_all_)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0)
;
#line 48 "./SQLite.xsi"
    D_imp_drh(drh);
    PERL_UNUSED_VAR(ix);
    ST(0) = dbd_discon_all(drh, imp_drh) ? &PL_sv_yes : &PL_sv_no;
#line 1457 "SQLite.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_DBD__SQLite__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__dr_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 62 "./SQLite.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 1499 "SQLite.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__SQLite__db__login); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db__login)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	dbname = ST(1)
;
	SV *	username = ST(2)
;
	SV *	password = ST(3)
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 92 "./SQLite.xsi"
    {
    D_imp_dbh(dbh);
#if !defined(dbd_db_login6_sv)
    STRLEN lna;
    char *u = (SvOK(username)) ? SvPV(username,lna) : (char*)"";
    char *p = (SvOK(password)) ? SvPV(password,lna) : (char*)"";
#endif
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &PL_sv_yes : &PL_sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 1546 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_selectall_arrayref)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 112 "./SQLite.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *tmp_sv;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 1565 "SQLite.c"
#line 119 "./SQLite.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::SQLite::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    tmp_sv = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
    SPAGAIN;
    ST(0) = tmp_sv;
#line 1612 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_selectrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 171 "./SQLite.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 1632 "SQLite.c"
#line 176 "./SQLite.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 1688 "SQLite.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_DBD__SQLite__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_do)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    {
	SV *	dbh = ST(0)
;
	char *	statement = (char *)SvPV_nolen(ST(1))
;
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2)
;
	}
#line 240 "./SQLite.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 1730 "SQLite.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_DBD__SQLite__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog, schema, table, field, attr=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	catalog = ST(1)
;
	SV *	schema = ST(2)
;
	SV *	table = ST(3)
;
	SV *	field = ST(4)
;
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 267 "./SQLite.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 1770 "SQLite.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__SQLite__db_commit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_commit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 279 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 1791 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_rollback)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 289 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 1811 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 299 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !PL_dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? (char*)"" : (char*)"s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 1842 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 322 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 1869 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_FETCH)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
#line 336 "./SQLite.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 1892 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
#line 347 "./SQLite.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !PL_dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* wants ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!PL_dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 1955 "SQLite.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_DBD__SQLite__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_take_imp_data)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0)
;
#line 400 "./SQLite.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::SQLite::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 1989 "SQLite.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_DBD__SQLite__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 424 "./SQLite.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 2031 "SQLite.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__SQLite__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st__prepare)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2)
;
	}
#line 453 "./SQLite.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 2068 "SQLite.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_DBD__SQLite__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 470 "./SQLite.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 2089 "SQLite.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_DBD__SQLite__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_bind_col)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	col = ST(1)
;
	SV *	ref = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 485 "./SQLite.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &PL_sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &PL_sv_yes : &PL_sv_no;
                break;
    default:    ST(0) = &PL_sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 2149 "SQLite.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS_EUPXS(XS_DBD__SQLite__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_bind_param)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 523 "./SQLite.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 2198 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_bind_param_inout)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value_ref = ST(2)
;
	IV	maxlen = (IV)SvIV(ST(3))
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 553 "./SQLite.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 2253 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_execute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_execute)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0)
;
#line 584 "./SQLite.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 2287 "SQLite.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAJ 1


XS_EUPXS(XS_DBD__SQLite__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_execute_for_fetch)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	fetch_tuple_sub = ST(1)
;
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2)
;
	}
#line 612 "./SQLite.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 2320 "SQLite.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__SQLite__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_fetchrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 627 "./SQLite.xsi"
    D_imp_sth(sth);
    AV *av;
    PERL_UNUSED_VAR(ix);
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 2343 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_fetchrow_array)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 640 "./SQLite.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        PERL_UNUSED_VAR(ix);
    }
#line 2374 "SQLite.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__SQLite__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_fetchall_arrayref)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0)
;
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1)
;
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2)
;
	}
#line 660 "./SQLite.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::SQLite::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        SV *tmp = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
        SPAGAIN;
        ST(0) = tmp;
    }
#line 2417 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 676 "./SQLite.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#endif
#line 2450 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_blob_read)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0)
;
	int	field = (int)SvIV(ST(1))
;
	long	offset = (long)SvIV(ST(2))
;
	long	len = (long)SvIV(ST(3))
;
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4)
;
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5))
;
	}
#line 704 "./SQLite.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 2496 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 720 "./SQLite.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 2523 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_FETCH_attrib)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
#line 737 "./SQLite.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    PERL_UNUSED_VAR(ix);
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 2549 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 750 "./SQLite.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !PL_dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) {  /* wants ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 2598 "SQLite.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'SQLite.xs' from 'SQLite.xsi' */

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_DBD__SQLite); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_DBD__SQLite)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        cv = newXS("DBD::SQLite::db::last_insert_rowid", XS_DBD__SQLite__db_last_insert_rowid, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_last_insert_rowid", XS_DBD__SQLite__db_last_insert_rowid, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::create_function", XS_DBD__SQLite__db_create_function, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_create_function", XS_DBD__SQLite__db_create_function, file);
        XSANY.any_i32 = 1;
#if XSubPPtmpAAAA
        cv = newXS("DBD::SQLite::db::enable_load_extension", XS_DBD__SQLite__db_enable_load_extension, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_enable_load_extension", XS_DBD__SQLite__db_enable_load_extension, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::load_extension", XS_DBD__SQLite__db_load_extension, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_load_extension", XS_DBD__SQLite__db_load_extension, file);
        XSANY.any_i32 = 1;
#endif
        cv = newXS("DBD::SQLite::db::create_aggregate", XS_DBD__SQLite__db_create_aggregate, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_create_aggregate", XS_DBD__SQLite__db_create_aggregate, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::create_collation", XS_DBD__SQLite__db_create_collation, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_create_collation", XS_DBD__SQLite__db_create_collation, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::collation_needed", XS_DBD__SQLite__db_collation_needed, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_collation_needed", XS_DBD__SQLite__db_collation_needed, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::progress_handler", XS_DBD__SQLite__db_progress_handler, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_progress_handler", XS_DBD__SQLite__db_progress_handler, file);
        XSANY.any_i32 = 1;
        newXS("DBD::SQLite::db::sqlite_trace", XS_DBD__SQLite__db_sqlite_trace, file);
        cv = newXS("DBD::SQLite::db::profile", XS_DBD__SQLite__db_profile, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_profile", XS_DBD__SQLite__db_profile, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::commit_hook", XS_DBD__SQLite__db_commit_hook, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_commit_hook", XS_DBD__SQLite__db_commit_hook, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::rollback_hook", XS_DBD__SQLite__db_rollback_hook, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_rollback_hook", XS_DBD__SQLite__db_rollback_hook, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::sqlite_update_hook", XS_DBD__SQLite__db_update_hook, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::update_hook", XS_DBD__SQLite__db_update_hook, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::set_authorizer", XS_DBD__SQLite__db_set_authorizer, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_set_authorizer", XS_DBD__SQLite__db_set_authorizer, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::busy_timeout", XS_DBD__SQLite__db_busy_timeout, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_busy_timeout", XS_DBD__SQLite__db_busy_timeout, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::backup_from_file", XS_DBD__SQLite__db_backup_from_file, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_backup_from_file", XS_DBD__SQLite__db_backup_from_file, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::backup_to_file", XS_DBD__SQLite__db_backup_to_file, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_backup_to_file", XS_DBD__SQLite__db_backup_to_file, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::sqlite_table_column_metadata", XS_DBD__SQLite__db_table_column_metadata, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::table_column_metadata", XS_DBD__SQLite__db_table_column_metadata, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::db_filename", XS_DBD__SQLite__db_db_filename, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_db_filename", XS_DBD__SQLite__db_db_filename, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::register_fts3_perl_tokenizer", XS_DBD__SQLite__db_register_fts3_perl_tokenizer, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_register_fts3_perl_tokenizer", XS_DBD__SQLite__db_register_fts3_perl_tokenizer, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::db_status", XS_DBD__SQLite__db_db_status, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::db::sqlite_db_status", XS_DBD__SQLite__db_db_status, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::sqlite_st_status", XS_DBD__SQLite__st_st_status, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::st_status", XS_DBD__SQLite__st_st_status, file);
        XSANY.any_i32 = 0;
        (void)newXSproto_portable("DBD::SQLite::compile_options", XS_DBD__SQLite_compile_options, file, "");
        (void)newXSproto_portable("DBD::SQLite::sqlite_status", XS_DBD__SQLite_sqlite_status, file, ";$");
        (void)newXSproto_portable("DBD::SQLite::OK", XS_DBD__SQLite_OK, file, "");
        (void)newXSproto_portable("DBD::SQLite::DENY", XS_DBD__SQLite_DENY, file, "");
        (void)newXSproto_portable("DBD::SQLite::IGNORE", XS_DBD__SQLite_IGNORE, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_INDEX", XS_DBD__SQLite_CREATE_INDEX, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_TABLE", XS_DBD__SQLite_CREATE_TABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_TEMP_INDEX", XS_DBD__SQLite_CREATE_TEMP_INDEX, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_TEMP_TABLE", XS_DBD__SQLite_CREATE_TEMP_TABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_TEMP_TRIGGER", XS_DBD__SQLite_CREATE_TEMP_TRIGGER, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_TEMP_VIEW", XS_DBD__SQLite_CREATE_TEMP_VIEW, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_TRIGGER", XS_DBD__SQLite_CREATE_TRIGGER, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_VIEW", XS_DBD__SQLite_CREATE_VIEW, file, "");
        (void)newXSproto_portable("DBD::SQLite::DELETE", XS_DBD__SQLite_DELETE, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_INDEX", XS_DBD__SQLite_DROP_INDEX, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_TABLE", XS_DBD__SQLite_DROP_TABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_TEMP_INDEX", XS_DBD__SQLite_DROP_TEMP_INDEX, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_TEMP_TABLE", XS_DBD__SQLite_DROP_TEMP_TABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_TEMP_TRIGGER", XS_DBD__SQLite_DROP_TEMP_TRIGGER, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_TEMP_VIEW", XS_DBD__SQLite_DROP_TEMP_VIEW, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_TRIGGER", XS_DBD__SQLite_DROP_TRIGGER, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_VIEW", XS_DBD__SQLite_DROP_VIEW, file, "");
        (void)newXSproto_portable("DBD::SQLite::INSERT", XS_DBD__SQLite_INSERT, file, "");
        (void)newXSproto_portable("DBD::SQLite::PRAGMA", XS_DBD__SQLite_PRAGMA, file, "");
        (void)newXSproto_portable("DBD::SQLite::READ", XS_DBD__SQLite_READ, file, "");
        (void)newXSproto_portable("DBD::SQLite::SELECT", XS_DBD__SQLite_SELECT, file, "");
        (void)newXSproto_portable("DBD::SQLite::TRANSACTION", XS_DBD__SQLite_TRANSACTION, file, "");
        (void)newXSproto_portable("DBD::SQLite::UPDATE", XS_DBD__SQLite_UPDATE, file, "");
        (void)newXSproto_portable("DBD::SQLite::ATTACH", XS_DBD__SQLite_ATTACH, file, "");
        (void)newXSproto_portable("DBD::SQLite::DETACH", XS_DBD__SQLite_DETACH, file, "");
        (void)newXSproto_portable("DBD::SQLite::ALTER_TABLE", XS_DBD__SQLite_ALTER_TABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::REINDEX", XS_DBD__SQLite_REINDEX, file, "");
        (void)newXSproto_portable("DBD::SQLite::ANALYZE", XS_DBD__SQLite_ANALYZE, file, "");
        (void)newXSproto_portable("DBD::SQLite::CREATE_VTABLE", XS_DBD__SQLite_CREATE_VTABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::DROP_VTABLE", XS_DBD__SQLite_DROP_VTABLE, file, "");
        (void)newXSproto_portable("DBD::SQLite::FUNCTION", XS_DBD__SQLite_FUNCTION, file, "");
        (void)newXSproto_portable("DBD::SQLite::SAVEPOINT", XS_DBD__SQLite_SAVEPOINT, file, "");
        newXS("DBD::SQLite::dr::dbixs_revision", XS_DBD__SQLite__dr_dbixs_revision, file);
#if XSubPPtmpAAAB
        cv = newXS("DBD::SQLite::dr::discon_all_", XS_DBD__SQLite__dr_discon_all_, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::dr::disconnect_all", XS_DBD__SQLite__dr_discon_all_, file);
        XSANY.any_i32 = 1;
#endif
#if XSubPPtmpAAAC
        newXS("DBD::SQLite::dr::data_sources", XS_DBD__SQLite__dr_data_sources, file);
#endif
        newXS("DBD::SQLite::db::_login", XS_DBD__SQLite__db__login, file);
        newXS("DBD::SQLite::db::selectall_arrayref", XS_DBD__SQLite__db_selectall_arrayref, file);
        cv = newXS("DBD::SQLite::db::selectrow_array", XS_DBD__SQLite__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::selectrow_arrayref", XS_DBD__SQLite__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0;
#if XSubPPtmpAAAD
        newXS("DBD::SQLite::db::do", XS_DBD__SQLite__db_do, file);
#endif
#if XSubPPtmpAAAE
        newXS("DBD::SQLite::db::last_insert_id", XS_DBD__SQLite__db_last_insert_id, file);
#endif
        newXS("DBD::SQLite::db::commit", XS_DBD__SQLite__db_commit, file);
        newXS("DBD::SQLite::db::rollback", XS_DBD__SQLite__db_rollback, file);
        newXS("DBD::SQLite::db::disconnect", XS_DBD__SQLite__db_disconnect, file);
        newXS("DBD::SQLite::db::STORE", XS_DBD__SQLite__db_STORE, file);
        newXS("DBD::SQLite::db::FETCH", XS_DBD__SQLite__db_FETCH, file);
        newXS("DBD::SQLite::db::DESTROY", XS_DBD__SQLite__db_DESTROY, file);
#if XSubPPtmpAAAF
        newXS("DBD::SQLite::db::take_imp_data", XS_DBD__SQLite__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAG
        newXS("DBD::SQLite::db::data_sources", XS_DBD__SQLite__db_data_sources, file);
#endif
        newXS("DBD::SQLite::st::_prepare", XS_DBD__SQLite__st__prepare, file);
#if XSubPPtmpAAAH
        newXS("DBD::SQLite::st::rows", XS_DBD__SQLite__st_rows, file);
#endif
#if XSubPPtmpAAAI
        newXS("DBD::SQLite::st::bind_col", XS_DBD__SQLite__st_bind_col, file);
#endif
        newXS("DBD::SQLite::st::bind_param", XS_DBD__SQLite__st_bind_param, file);
        newXS("DBD::SQLite::st::bind_param_inout", XS_DBD__SQLite__st_bind_param_inout, file);
        newXS("DBD::SQLite::st::execute", XS_DBD__SQLite__st_execute, file);
#if XSubPPtmpAAAJ
        newXS("DBD::SQLite::st::execute_for_fetch", XS_DBD__SQLite__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::SQLite::st::fetch", XS_DBD__SQLite__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::fetchrow_arrayref", XS_DBD__SQLite__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::st::fetchrow", XS_DBD__SQLite__st_fetchrow_array, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::fetchrow_array", XS_DBD__SQLite__st_fetchrow_array, file);
        XSANY.any_i32 = 0;
        newXS("DBD::SQLite::st::fetchall_arrayref", XS_DBD__SQLite__st_fetchall_arrayref, file);
        newXS("DBD::SQLite::st::finish", XS_DBD__SQLite__st_finish, file);
        newXS("DBD::SQLite::st::blob_read", XS_DBD__SQLite__st_blob_read, file);
        newXS("DBD::SQLite::st::STORE", XS_DBD__SQLite__st_STORE, file);
        cv = newXS("DBD::SQLite::st::FETCH", XS_DBD__SQLite__st_FETCH_attrib, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::FETCH_attrib", XS_DBD__SQLite__st_FETCH_attrib, file);
        XSANY.any_i32 = 0;
        newXS("DBD::SQLite::st::DESTROY", XS_DBD__SQLite__st_DESTROY, file);

    /* Initialisation Section */

#line 12 "SQLite.xs"
    sv_setpv(get_sv("DBD::SQLite::sqlite_version",        TRUE|GV_ADDMULTI), SQLITE_VERSION);
    sv_setiv(get_sv("DBD::SQLite::sqlite_version_number", TRUE|GV_ADDMULTI), SQLITE_VERSION_NUMBER);

#if XSubPPtmpAAAA
#endif
#line 18 "./SQLite.xsi"
    PERL_UNUSED_VAR(items);
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::SQLite::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::SQLite::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::SQLite::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#line 2851 "SQLite.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

